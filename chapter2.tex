\chapter{Design}

\section{Why Rust?}
\label{sec:why-rust}

\gls{aucpace} explicitly targets \gls{iiot} in it's design.
Rust is rapidly becoming a popular choice for \gls{iot} and embedded software applications.
This is due to it's focus on memory safety, developer experience and it's strong embedded ecosystem.
Libraries like Embassy and RTIC allow the user to program high level logic and use powerful abstractions to interact with the hardware through Rust objects, while still compiling down to small efficient binaries.
Embassy is especially impressive as they have implemented a async executor so that multitasking in embedded applications can be performed with the same async/await framework that programmers are familiar with.
A short Embassy examples is shown in listing \ref{embassy-example}.
Tools such as \texttt{probe-rs} allow developers to maintain the same workflow they would when working on a normal rust binary, by implementing a \texttt{cargo} runner which flashes the binary to the embedded device then using \gls{rtt} to receive debug messages from the device.
Those debug messages can be setup automatically using libraries such as \texttt{defmt\_rtt} which use \gls{rtt} to send a compressed representation of the debug message to be formatted later on using a technique called deferred formatting, allowing for debug messages to take up a fraction of the size of the original message.
Together this makes rust a compelling choice for writing embedded code.

\medskip{}

\rustcode[label=embassy-example]{Embassy async/await example}{assets/embassy_example.rs}

Rust is also very well suited for implementing cryptographic software.
It's lifetimes system and compile time safety guarantees make it ideal for building security focused software.
Rust was recently added to \gls{nist}'s list of "Safer Languages" which it recommends for writing safety focussed programs in \cite{nist-safer-languages}.

As well as this many algorithms, formats and primitives are implemented, and freely available as crates for anyone to use.
Rust's trait system also lends itself well to this, it is possible to use implement a trait representing an elliptic curve and then an algorithm can be written to be agnostic about the curve that it is using for instance.
This allows library writers to easily write generic code to give user's of the libraries as much flexibility and choice around how they implement their program.
This is especially important for systems which might need to interact with legacy systems or that need to provide a certain level of security for \gls{fips} standards like \gls{fips}-140-2 \cite{fips-140-2}.

\section{Planning the library}
Before implementing \gls{aucpace} it was necessary to plan ahead what libraries to use.
Without planning it would be easy to end up in a situation where different libraries aren't compatible with each other, or have become superseded by another library as this information is not readily available on \href{https://crates.io/}{crates.io} (crates.io is the package repository for all public rust packages).

\subsection{What primitives do we need to implement AuCPace?}
\gls{aucpace} has many parameters which can be changed to drastically change how the protocol works, this is by design to allow customisability for each user's needs, however it can be quite confusing to navigate.
As such it is worthwhile to look at the parameters are and thus what primitives we will need.
\Cref{tab:aucpace-params,tab:aucpace-selected-params} are partially reproduced from \cite{aucpace} just in significantly fewer words.

\begin{center}
  \rowcolors{2}{mintbg}{}
  \captionof{table}{\gls{aucpace} Parameters}
  \label{tab:aucpace-params}
  \begin{tabular}{ cp{0.8\linewidth} }
    \toprule
    parameter & explanation \\
    \midrule
    $\textsf{PBKDF}_{\sigma}$ & A \gls{pbkdf} parameterised by $\sigma$.
    The parameters of the \gls{pbkdf} are algorithm specific, but usually would include settings such as the memory consumption of the algorithm, the hash used or the iteration count (number of times to perform the hash). \\
    $\mathcal{C}, \mathcal{J}, c_{\mathcal{J}}, B$ & A (hyper-)elliptic curve $\mathcal{C}$ with a group $\mathcal{J}$ with co-factor $c_{\mathcal{J}}$ and a \gls{dh} protocol operating on both, $\mathcal{C}$ and it's quadratic twist $\mathcal{C}'$. $B$ denotes the \gls{dh} base point in $\mathcal{J}$.\\
    \textsf{Map2Point} & A function mapping a string $s$ to a point from a cryptographically large subgroup $\mathcal{J}_m$ of $\mathcal{C}$. The inverse map $\textsf{Map2Point}^{-1}$ is also required.\\
    $\textsf{H}_0 \dots \textsf{H}_5$ & A set of 6 distinct hash functions.\\
    \bottomrule
  \end{tabular}
\end{center}

\begin{center}
  \rowcolors{2}{mintbg}{}
  \captionof{table}{Selected parameters of the reference implementation -- AuCPace25519}
  \label{tab:aucpace-selected-params}
  \begin{tabular}{ cp{0.8\linewidth} }
    \toprule
    parameter & explanation \\
    \midrule
    $\textsf{PBKDF}_{\sigma}$ & Scrypt \cite{scrypt} an optimally memory-hard \cite{scrypt-max-mem-hard} \gls{pbkdf}, parameterised with a memory usage of 32Mb.\\
    $\mathcal{C}, \mathcal{J}, c_{\mathcal{J}}, B$ & Curve25519 \cite{curve25519} a Montgomery form elliptic curve, with excellent speed properties.
      X25519 an x-coordinate-only \gls{dh} protocol.\\
    \textsf{Map2Point} & The Elligator2 map introduced by \citeauthor{elligator2} in \cite{elligator2}.\\
    $\textsf{H}_0 \dots \textsf{H}_5$ & The \glslink{sha}{SHA512} hash function where the index is prepended as a little-endian four-byte word.\\
    \bottomrule
  \end{tabular}
\end{center}

So in summary we need the following primitives:
\begin{itemize}
  \item{a \gls{pbkdf}}
  \item{an elliptic curve, a group on the curve, a \gls{dh} protocol operating on the group}
  \item{a mapping from strings to curve points}
  \item{a hash function}
\end{itemize}

\subsection{What rust libraries actually exist for cryptography?}
There are many sites online which act as collections of rust packages that you can search by topic to find similar or related packages.
The \gls{rcig} maintain a list of Rust's Cryptographic libraries at \url{https://cryptography.rs/}, this proved to be a great help while researching libraries.

For the required primitives the following Rust crates were identified as potential candidates:
\begin{itemize}
  \item{
    The \gls{pbkdf}:
    \begin{itemize}
      \item{\href{https://github.com/RustCrypto/password-hashes/tree/master/argon2}{\texttt{argon2}} - RustCrypto's Argon2 implementation}
      \item{\href{https://github.com/RustCrypto/password-hashes/tree/master/pbkdf2}{\texttt{pbkdf2}} - RustCrypto's PBKDF2 implementation}
      \item{\href{https://github.com/RustCrypto/password-hashes/tree/master/scrypt}{\texttt{scrypt}} - RustCrypto's Scrypt implementation}
      \item{\href{https://github.com/Keats/rust-bcrypt}{\texttt{rust-bcrypt}} - a pure Rust Bcrypt implementation}
      \item{\href{https://github.com/sru-systems/rust-argon2}{\texttt{rust-argon2}} - a pure Rust Argon2 implementation}
      \item{\href{https://github.com/RustCrypto/traits/tree/master/password-hash}{password-hash} - trait to allow implementations to be generic over the password hashing algorithm used}
    \end{itemize}
  }

  \item{
    The elliptic curve:
    \begin{itemize}
      \item{\href{https://github.com/dalek-cryptography/curve25519-dalek}{\texttt{curve25519-dalek}} - Dalek Cryptography's implementation of Curve25519 and Ristretto255 \cite{ristretto255}}
      \item{\href{https://github.com/RustCrypto/traits/tree/master/elliptic-curve}{\texttt{elliptic-curve}} - traits for operating over a generic elliptic curve, part of RustCrypto}
      \item{\href{https://github.com/RustCrypto/elliptic-curves}{\texttt{elliptic-curves}} - RustCrypto's meta-repo holding implementations for the following curves: brainpoolP256r1/t1, brainpoolP384r1/t1, Secp256k1, P-224, P-256, P-384, 1P-52}
    \end{itemize}
  }

  \item{
    The \textsf{Map2Point} function:
    \begin{itemize}
      \item{\href{https://github.com/dalek-cryptography/curve25519-dalek}{\texttt{curve25519-dalek}} - includes \verb|RistrettoPoint::from_uniform_bytes| which implements Ristretto flavoured Elligator2}
      \item{\href{https://github.com/RustCrypto/traits/tree/master/elliptic-curve}{\texttt{elliptic-curve}} - includes \texttt{MapToCurve} which implements the hash-to-curve operation for NIST P-256 and Secp256k1}
    \end{itemize}
  }

  \item{
    The hash function:
    \begin{itemize}
      \item{\href{https://github.com/RustCrypto/traits/tree/master/digest}{\texttt{digest}} - a trait for operating generically over hash functions, from RustCrypto}
      \item{\href{https://github.com/RustCrypto/hashes}{\texttt{hashes}} - RustCrypto's meta-repo holding implementations for the following hashes: Ascon, BLAKE2. KangarooTwelve, SHA2, SHA3, Tiger, Whirlpool, and several more.}
    \end{itemize}
  }
\end{itemize}

\subsection{Picking crates for the required primitives}
Where possible the implementation should match the reference implementation.
These choices are what the designers have determined as secure presets so the are good choices should a suitable crate exist.

\subsubsection{Choosing the PBKDF}
Instead of picking a \gls{pbkdf} up front, the \texttt{PasswordHasher} trait from \href{https://github.com/RustCrypto/traits/tree/master/password-hash}{password-hash} allows us to be generic over the \gls{pbkdf} when implmenting the library.
Allowing users of the library to pick from either Argon2, Scrypt or PBKDF2 at their discrection, or to implement their own algorithm and supply an implementation of \texttt{PasswordHasher} for it.

\subsubsection{Choosing the Curve and \textsf{Map2Point} operation}
Although the \texttt{elliptic-curves} repo implements many different elliptic curves, it doesn't implement Curve25519\footnote{there is currently a push to have it included in the crate, though it is still early on and the implementation is not fit for use}, and the \texttt{hash2curve} \gls{api} for \gls{nist} P-256 uses the \gls{osswu} map ycite{osswu-map}, which is known to be less efficient than the Elligator2 map defined for Montomery curves.
There have also been questions about whether the coefficients used in \gls{nist}'s suite of curves have been deliberately tampered with \cite{curve-rigidity}.

Another issue to consider when picking a curve and group is the problem of cofactor handling.
To avoid mishandling group cofactors \gls{aucpace} shows everywhere a cofactor multiplication is necessary, failing to perform one of these multiplications would be a serious bug.
However we can eliminate the need for handling cofactors altogether by using a prime order group, that is a group with a prime number of elements in it.
Ristretto255 \cite{ristretto255} is one such group built on top of Curve25519.
The \texttt{curve25519-dalek} crate implements Ristretto255 as well as the Ristretto flavoured Elligator2 map \cite{elligator2} which implements the required \textsf{Map2Point} operation.

\subsubsection{Choosing the hash function}
The hash function is another parameter that is easy to be generic over, thanks to the \texttt{digest} crate.
This allows users to pick from the plethora of hashes implemented by \texttt{RustCrypto/hashes}, enabling them to choose whichever hash function is best suited for their application.

\section{Initial Proof of Concept design}
Creating a \gls{poc} design before implementing the full library functionality, makes it easy to prototype quickly and to understand how the different components will interact with each other.
It also informs later design decisions 

\section{Improving the initial design}

% \section{Developer Focussed Design}


